/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => JDexAIFilerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  provider: "openai",
  openaiApiKey: "",
  openaiModel: "gpt-4o-mini",
  anthropicApiKey: "",
  anthropicModel: "claude-sonnet-4-20250514",
  ollamaEndpoint: "http://localhost:11434",
  ollamaModel: "llama3.2",
  openrouterApiKey: "",
  openrouterModel: "anthropic/claude-3.5-sonnet",
  jdexRootFolder: "",
  addTimestamp: true,
  timestampFormat: "YYYY-MM-DD HH:mm",
  defaultHeader: "",
  showInRibbon: true,
  maxSuggestions: 3,
  maxTokens: 500,
  temperature: 0.3,
  cacheJdexIndex: true,
  cacheTimeout: 30
};

// src/settings/settingsTab.ts
var import_obsidian2 = require("obsidian");

// src/utils/folderPicker.ts
var import_obsidian = require("obsidian");
async function pickFolder() {
  if (!import_obsidian.Platform.isDesktopApp) {
    return null;
  }
  try {
    const { remote } = require("@electron/remote");
    const result = await remote.dialog.showOpenDialog({
      properties: ["openDirectory"],
      title: "Select JDex Folder"
    });
    if (!result.canceled && result.filePaths.length > 0) {
      return result.filePaths[0];
    }
  } catch (e) {
    try {
      const electron = require("electron");
      const result = await electron.remote.dialog.showOpenDialog({
        properties: ["openDirectory"],
        title: "Select JDex Folder"
      });
      if (!result.canceled && result.filePaths.length > 0) {
        return result.filePaths[0];
      }
    } catch (e2) {
      console.error("Native folder picker not available:", e2);
    }
  }
  return null;
}
function isAbsolutePath(p) {
  if (!p) return false;
  return p.startsWith("/") || /^[A-Z]:\\/i.test(p);
}

// src/settings/settingsTab.ts
var JDexAIFilerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "JDex AI Filer Settings" });
    new import_obsidian2.Setting(containerEl).setName("LLM Provider").setDesc("Select your AI provider for filing suggestions").addDropdown((dropdown) => dropdown.addOption("openrouter", "OpenRouter (Multi-Model)").addOption("openai", "OpenAI").addOption("anthropic", "Anthropic Claude").addOption("ollama", "Ollama (Local)").setValue(this.plugin.settings.provider).onChange(async (value) => {
      this.plugin.settings.provider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.provider === "openrouter") {
      this.displayOpenRouterSettings(containerEl);
    } else if (this.plugin.settings.provider === "openai") {
      this.displayOpenAISettings(containerEl);
    } else if (this.plugin.settings.provider === "anthropic") {
      this.displayAnthropicSettings(containerEl);
    } else {
      this.displayOllamaSettings(containerEl);
    }
    containerEl.createEl("h3", { text: "JDex Location" });
    new import_obsidian2.Setting(containerEl).setName("JDex root folder").setDesc("Folder containing your JDex structure (can be anywhere on your system)").addText((text) => {
      text.setValue(this.plugin.settings.jdexRootFolder || "").setPlaceholder("/path/to/jdex-folder").onChange(async (value) => {
        this.plugin.settings.jdexRootFolder = value;
        this.plugin.jdexParser.clearCache();
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "300px";
    }).addButton((button) => button.setButtonText("Browse").onClick(async () => {
      const folder = await pickFolder();
      if (folder) {
        this.plugin.settings.jdexRootFolder = folder;
        this.plugin.jdexParser.clearCache();
        await this.plugin.saveSettings();
        this.display();
      } else {
        new import_obsidian2.Notice("Folder picker not available. Please enter the path manually.");
      }
    }));
    containerEl.createEl("h3", { text: "Filing Behavior" });
    new import_obsidian2.Setting(containerEl).setName("Add timestamp").setDesc("Add filing timestamp to appended content").addToggle((toggle) => toggle.setValue(this.plugin.settings.addTimestamp).onChange(async (value) => {
      this.plugin.settings.addTimestamp = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Timestamp format").setDesc("Format for timestamps (moment.js format)").addText((text) => text.setPlaceholder("YYYY-MM-DD HH:mm").setValue(this.plugin.settings.timestampFormat).onChange(async (value) => {
      this.plugin.settings.timestampFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Default header").setDesc("Append content under this header (leave empty for end of file)").addText((text) => text.setPlaceholder("## Notes").setValue(this.plugin.settings.defaultHeader).onChange(async (value) => {
      this.plugin.settings.defaultHeader = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "UI Preferences" });
    new import_obsidian2.Setting(containerEl).setName("Show ribbon icon").setDesc("Show JDex AI Filer icon in the left ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.showInRibbon).onChange(async (value) => {
      this.plugin.settings.showInRibbon = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Max suggestions").setDesc("Maximum number of filing suggestions to show (1-5)").addSlider((slider) => slider.setLimits(1, 5, 1).setValue(this.plugin.settings.maxSuggestions).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxSuggestions = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced" });
    new import_obsidian2.Setting(containerEl).setName("Cache JDex index").setDesc("Cache the vault structure to speed up suggestions").addToggle((toggle) => toggle.setValue(this.plugin.settings.cacheJdexIndex).onChange(async (value) => {
      this.plugin.settings.cacheJdexIndex = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Cache timeout (minutes)").setDesc("How long to cache the JDex index").addText((text) => text.setPlaceholder("30").setValue(String(this.plugin.settings.cacheTimeout)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.cacheTimeout = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Temperature").setDesc("LLM temperature (0 = deterministic, 1 = creative)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
  }
  displayOpenAISettings(containerEl) {
    containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Your OpenAI API key").addText((text) => {
      text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("OpenAI model to use").addDropdown((dropdown) => dropdown.addOption("gpt-4o-mini", "GPT-4o Mini (Fast, Cheap)").addOption("gpt-4o", "GPT-4o (Best)").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo (Legacy)").setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
      this.plugin.settings.openaiModel = value;
      await this.plugin.saveSettings();
    }));
  }
  displayAnthropicSettings(containerEl) {
    containerEl.createEl("h3", { text: "Anthropic Settings" });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Your Anthropic API key").addText((text) => {
      text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("Anthropic model to use").addDropdown((dropdown) => dropdown.addOption("claude-sonnet-4-20250514", "Claude Sonnet 4 (Recommended)").addOption("claude-3-5-haiku-20241022", "Claude 3.5 Haiku (Fast)").addOption("claude-3-5-sonnet-20241022", "Claude 3.5 Sonnet").setValue(this.plugin.settings.anthropicModel).onChange(async (value) => {
      this.plugin.settings.anthropicModel = value;
      await this.plugin.saveSettings();
    }));
  }
  displayOpenRouterSettings(containerEl) {
    containerEl.createEl("h3", { text: "OpenRouter Settings" });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Your OpenRouter API key").addText((text) => {
      text.setPlaceholder("sk-or-...").setValue(this.plugin.settings.openrouterApiKey).onChange(async (value) => {
        this.plugin.settings.openrouterApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("OpenRouter model ID (e.g., anthropic/claude-3.5-sonnet)").addText((text) => text.setPlaceholder("anthropic/claude-3.5-sonnet").setValue(this.plugin.settings.openrouterModel).onChange(async (value) => {
      this.plugin.settings.openrouterModel = value;
      await this.plugin.saveSettings();
    }));
  }
  displayOllamaSettings(containerEl) {
    containerEl.createEl("h3", { text: "Ollama Settings" });
    new import_obsidian2.Setting(containerEl).setName("Endpoint").setDesc("Ollama server URL").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaEndpoint).onChange(async (value) => {
      this.plugin.settings.ollamaEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("Ollama model name").addText((text) => text.setPlaceholder("llama3.2").setValue(this.plugin.settings.ollamaModel).onChange(async (value) => {
      this.plugin.settings.ollamaModel = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/jdex/parser.ts
var import_obsidian3 = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var AREA_PATTERN = /^(\d{2})-(\d{2})\s+(.+)$/;
var CATEGORY_PATTERN = /^(\d{2})\s+(.+)$/;
var ID_PATTERN = /^(\d{2})\.(\d{2})\s+(.+)$/;
var JDexParser = class {
  constructor(app) {
    this.cache = null;
    this.cacheTimestamp = 0;
    this.cachedRootFolder = "";
    this.app = app;
  }
  /**
   * Get the JDex index, using cache if valid
   */
  async getIndex(rootFolder = "", useCache = true, cacheTimeout = 30) {
    const now = Date.now();
    const cacheAgeMinutes = (now - this.cacheTimestamp) / 1e3 / 60;
    if (this.cachedRootFolder !== rootFolder) {
      this.clearCache();
    }
    if (useCache && this.cache && cacheAgeMinutes < cacheTimeout) {
      return this.cache;
    }
    const index = await this.scanVault(rootFolder);
    this.cache = index;
    this.cacheTimestamp = now;
    this.cachedRootFolder = rootFolder;
    return index;
  }
  /**
   * Clear the cache
   */
  clearCache() {
    this.cache = null;
    this.cacheTimestamp = 0;
  }
  /**
   * Scan the vault or external folder for JDex structure
   */
  async scanVault(rootFolderPath = "") {
    if (isAbsolutePath(rootFolderPath)) {
      return this.scanExternalFolder(rootFolderPath);
    }
    return this.scanVaultFolder(rootFolderPath);
  }
  /**
   * Scan a vault folder for JDex structure
   */
  async scanVaultFolder(rootFolderPath = "") {
    const areas = [];
    let startFolder;
    if (rootFolderPath) {
      const folder = this.app.vault.getAbstractFileByPath(rootFolderPath);
      if (folder instanceof import_obsidian3.TFolder) {
        startFolder = folder;
      } else {
        startFolder = this.app.vault.getRoot();
      }
    } else {
      startFolder = this.app.vault.getRoot();
    }
    for (const child of startFolder.children) {
      if (child instanceof import_obsidian3.TFolder) {
        const area = await this.parseAreaFolder(child);
        if (area) {
          areas.push(area);
        }
      }
    }
    areas.sort((a, b) => a.id.localeCompare(b.id));
    return {
      areas,
      lastUpdated: Date.now()
    };
  }
  /**
   * Scan an external folder (outside vault) for JDex structure
   */
  async scanExternalFolder(folderPath) {
    const areas = [];
    if (!fs.existsSync(folderPath)) {
      console.error("JDex folder not found:", folderPath);
      return { areas, lastUpdated: Date.now() };
    }
    try {
      const entries = fs.readdirSync(folderPath, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const areaPath = path.join(folderPath, entry.name);
          const area = this.parseExternalAreaFolder(areaPath, entry.name);
          if (area) {
            areas.push(area);
          }
        }
      }
      areas.sort((a, b) => a.id.localeCompare(b.id));
    } catch (error) {
      console.error("Error scanning external folder:", error);
    }
    return {
      areas,
      lastUpdated: Date.now()
    };
  }
  /**
   * Parse an external area folder (XX-XX pattern)
   */
  parseExternalAreaFolder(folderPath, folderName) {
    const match = folderName.match(AREA_PATTERN);
    if (!match) return null;
    const areaId = `${match[1]}-${match[2]}`;
    const areaName = match[3].trim();
    const categories = [];
    try {
      const entries = fs.readdirSync(folderPath, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const categoryPath = path.join(folderPath, entry.name);
          const category = this.parseExternalCategoryFolder(categoryPath, entry.name, areaId);
          if (category) {
            categories.push(category);
          }
        }
      }
      categories.sort((a, b) => a.id.localeCompare(b.id));
    } catch (error) {
      console.error("Error parsing external area folder:", error);
    }
    return {
      id: areaId,
      name: areaName,
      path: folderPath,
      categories
    };
  }
  /**
   * Parse an external category folder (XX pattern)
   */
  parseExternalCategoryFolder(folderPath, folderName, areaId) {
    const match = folderName.match(CATEGORY_PATTERN);
    if (!match) return null;
    const categoryId = match[1];
    const categoryName = match[2].trim();
    const areaStart = parseInt(areaId.split("-")[0]);
    const areaEnd = parseInt(areaId.split("-")[1]);
    const catNum = parseInt(categoryId);
    if (catNum < areaStart || catNum > areaEnd) {
      return null;
    }
    const items = [];
    try {
      const entries = fs.readdirSync(folderPath, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith(".md")) {
          const filePath = path.join(folderPath, entry.name);
          const item = this.parseExternalIdFile(filePath, entry.name, categoryId);
          if (item) {
            items.push(item);
          }
        } else if (entry.isDirectory() && !entry.name.startsWith(".")) {
          const idFolderPath = path.join(folderPath, entry.name);
          const item = this.parseExternalIdFolder(idFolderPath, entry.name, categoryId);
          if (item) {
            items.push(item);
          }
        }
      }
      items.sort((a, b) => a.id.localeCompare(b.id));
    } catch (error) {
      console.error("Error parsing external category folder:", error);
    }
    return {
      id: categoryId,
      name: categoryName,
      path: folderPath,
      items
    };
  }
  /**
   * Parse an external ID file (XX.XX pattern)
   */
  parseExternalIdFile(filePath, fileName, categoryId) {
    const baseName = fileName.replace(/\.md$/, "");
    const match = baseName.match(ID_PATTERN);
    if (!match) return null;
    const idCategory = match[1];
    const idNumber = match[2];
    const idName = match[3].trim();
    if (idCategory !== categoryId) {
      return null;
    }
    const fullId = `${idCategory}.${idNumber}`;
    const idNum = parseInt(idNumber);
    return {
      id: fullId,
      name: idName,
      path: filePath,
      isHeader: idNumber.endsWith("0") && idNum >= 10,
      isReserved: idNum < 10
    };
  }
  /**
   * Parse an external ID folder (XX.XX pattern) - for folder-based JDex structures
   */
  parseExternalIdFolder(folderPath, folderName, categoryId) {
    const match = folderName.match(ID_PATTERN);
    if (!match) return null;
    const idCategory = match[1];
    const idNumber = match[2];
    const idName = match[3].trim();
    if (idCategory !== categoryId) {
      return null;
    }
    const fullId = `${idCategory}.${idNumber}`;
    const idNum = parseInt(idNumber);
    const targetFile = path.join(folderPath, `${folderName}.md`);
    return {
      id: fullId,
      name: idName,
      path: targetFile,
      folderPath,
      isHeader: idNumber.endsWith("0") && idNum >= 10,
      isReserved: idNum < 10
    };
  }
  /**
   * Parse an area folder (XX-XX pattern)
   */
  async parseAreaFolder(folder) {
    const match = folder.name.match(AREA_PATTERN);
    if (!match) return null;
    const areaId = `${match[1]}-${match[2]}`;
    const areaName = match[3].trim();
    const categories = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian3.TFolder) {
        const category = await this.parseCategoryFolder(child, areaId);
        if (category) {
          categories.push(category);
        }
      }
    }
    categories.sort((a, b) => a.id.localeCompare(b.id));
    return {
      id: areaId,
      name: areaName,
      path: folder.path,
      categories
    };
  }
  /**
   * Parse a category folder (XX pattern)
   */
  async parseCategoryFolder(folder, areaId) {
    const match = folder.name.match(CATEGORY_PATTERN);
    if (!match) return null;
    const categoryId = match[1];
    const categoryName = match[2].trim();
    const areaStart = parseInt(areaId.split("-")[0]);
    const areaEnd = parseInt(areaId.split("-")[1]);
    const catNum = parseInt(categoryId);
    if (catNum < areaStart || catNum > areaEnd) {
      return null;
    }
    const items = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian3.TFile && child.extension === "md") {
        const item = this.parseIdFile(child, categoryId);
        if (item) {
          items.push(item);
        }
      } else if (child instanceof import_obsidian3.TFolder) {
        const item = this.parseIdFolder(child, categoryId);
        if (item) {
          items.push(item);
        }
      }
    }
    items.sort((a, b) => a.id.localeCompare(b.id));
    return {
      id: categoryId,
      name: categoryName,
      path: folder.path,
      items
    };
  }
  /**
   * Parse an ID folder (XX.XX pattern) - for folder-based JDex structures
   */
  parseIdFolder(folder, categoryId) {
    const match = folder.name.match(ID_PATTERN);
    if (!match) return null;
    const idCategory = match[1];
    const idNumber = match[2];
    const idName = match[3].trim();
    if (idCategory !== categoryId) {
      return null;
    }
    const fullId = `${idCategory}.${idNumber}`;
    const idNum = parseInt(idNumber);
    const targetFile = `${folder.path}/${folder.name}.md`;
    return {
      id: fullId,
      name: idName,
      path: targetFile,
      folderPath: folder.path,
      isHeader: idNumber.endsWith("0") && idNum >= 10,
      isReserved: idNum < 10
    };
  }
  /**
   * Parse an ID file (XX.XX pattern)
   */
  parseIdFile(file, categoryId) {
    const baseName = file.basename;
    const match = baseName.match(ID_PATTERN);
    if (!match) return null;
    const idCategory = match[1];
    const idNumber = match[2];
    const idName = match[3].trim();
    if (idCategory !== categoryId) {
      return null;
    }
    const fullId = `${idCategory}.${idNumber}`;
    const idNum = parseInt(idNumber);
    return {
      id: fullId,
      name: idName,
      path: file.path,
      isHeader: idNumber.endsWith("0") && idNum >= 10,
      // .X0 are section headers
      isReserved: idNum < 10
      // .00-.09 are reserved
    };
  }
  /**
   * Find a specific JDex item by ID
   */
  async findById(jdexId, rootFolder = "") {
    const index = await this.getIndex(rootFolder);
    for (const area of index.areas) {
      for (const category of area.categories) {
        for (const item of category.items) {
          if (item.id === jdexId) {
            return item;
          }
        }
      }
    }
    return null;
  }
  /**
   * Get all fileable items (non-header, non-reserved) for dropdown
   */
  async getFileableItems(rootFolder = "") {
    const index = await this.getIndex(rootFolder);
    const items = [];
    for (const area of index.areas) {
      for (const category of area.categories) {
        for (const item of category.items) {
          if (!item.isHeader && !item.isReserved) {
            items.push(item);
          }
        }
      }
    }
    return items;
  }
  /**
   * Get items formatted for dropdown: "14.11 - My computers & servers"
   */
  async getItemsForDropdown(rootFolder = "") {
    const items = await this.getFileableItems(rootFolder);
    return items.map((item) => ({
      id: item.id,
      label: `${item.id} - ${item.name}`,
      path: item.path
    }));
  }
};

// src/jdex/indexBuilder.ts
function buildCompactIndex(index) {
  const lines = [];
  lines.push("Available JDex locations:\n");
  for (const area of index.areas) {
    lines.push(`[${area.id}] ${area.name}`);
    for (const category of area.categories) {
      const fileableItems = category.items.filter((i) => !i.isHeader && !i.isReserved);
      if (fileableItems.length > 0) {
        lines.push(`  [${category.id}] ${category.name}`);
        for (const item of fileableItems) {
          lines.push(`    ${item.id} ${item.name}`);
        }
      }
    }
  }
  return lines.join("\n");
}

// src/providers/openaiProvider.ts
var import_obsidian4 = require("obsidian");

// src/providers/llmProvider.ts
var LLMProvider = class {
  /**
   * Parse the LLM response into structured suggestions
   */
  parseResponse(rawResponse) {
    try {
      const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        console.error("No JSON found in response");
        return [];
      }
      const parsed = JSON.parse(jsonMatch[0]);
      let suggestions = [];
      if (Array.isArray(parsed.suggestions)) {
        suggestions = parsed.suggestions;
      } else if (Array.isArray(parsed)) {
        suggestions = parsed;
      }
      return suggestions.filter((s) => s.jdexId && s.jdexName).map((s) => ({
        jdexId: String(s.jdexId),
        jdexName: String(s.jdexName),
        confidence: typeof s.confidence === "number" ? s.confidence : 0.5,
        reason: String(s.reason || "No reason provided"),
        targetPath: String(s.targetPath || "")
      }));
    } catch (error) {
      console.error("Failed to parse LLM response:", error);
      return [];
    }
  }
};

// src/providers/openaiProvider.ts
var OpenAIProvider = class extends LLMProvider {
  constructor(apiKey, model) {
    super();
    this.name = "OpenAI";
    this.apiKey = apiKey;
    this.model = model;
  }
  async sendRequest(request) {
    var _a, _b;
    const response = await (0, import_obsidian4.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.model,
        messages: [
          {
            role: "system",
            content: request.systemPrompt
          },
          {
            role: "user",
            content: request.userContent
          }
        ],
        max_tokens: request.maxTokens,
        temperature: request.temperature,
        response_format: { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenAI API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const rawResponse = ((_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "";
    const suggestions = this.parseResponse(rawResponse);
    return {
      suggestions,
      reasoning: this.extractReasoning(rawResponse),
      rawResponse
    };
  }
  async testConnection() {
    try {
      const response = await (0, import_obsidian4.requestUrl)({
        url: "https://api.openai.com/v1/models",
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        }
      });
      return response.status === 200;
    } catch (e) {
      return false;
    }
  }
  extractReasoning(rawResponse) {
    try {
      const parsed = JSON.parse(rawResponse);
      return parsed.reasoning || parsed.explanation || "";
    } catch (e) {
      return "";
    }
  }
};

// src/providers/anthropicProvider.ts
var import_obsidian5 = require("obsidian");
var AnthropicProvider = class extends LLMProvider {
  constructor(apiKey, model) {
    super();
    this.name = "Anthropic";
    this.apiKey = apiKey;
    this.model = model;
  }
  async sendRequest(request) {
    var _a;
    const response = await (0, import_obsidian5.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: request.maxTokens,
        system: request.systemPrompt,
        messages: [
          {
            role: "user",
            content: request.userContent
          }
        ]
      })
    });
    if (response.status !== 200) {
      throw new Error(`Anthropic API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const rawResponse = ((_a = data.content[0]) == null ? void 0 : _a.text) || "";
    const suggestions = this.parseResponse(rawResponse);
    return {
      suggestions,
      reasoning: this.extractReasoning(rawResponse),
      rawResponse
    };
  }
  async testConnection() {
    try {
      return this.apiKey.startsWith("sk-ant-");
    } catch (e) {
      return false;
    }
  }
  extractReasoning(rawResponse) {
    try {
      const parsed = JSON.parse(rawResponse);
      return parsed.reasoning || parsed.explanation || "";
    } catch (e) {
      return "";
    }
  }
};

// src/providers/ollamaProvider.ts
var import_obsidian6 = require("obsidian");
var OllamaProvider = class extends LLMProvider {
  constructor(endpoint, model) {
    super();
    this.name = "Ollama";
    this.endpoint = endpoint.replace(/\/$/, "");
    this.model = model;
  }
  async sendRequest(request) {
    const response = await (0, import_obsidian6.requestUrl)({
      url: `${this.endpoint}/api/generate`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.model,
        prompt: this.buildPrompt(request),
        stream: false,
        options: {
          temperature: request.temperature,
          num_predict: request.maxTokens
        },
        format: "json"
      })
    });
    if (response.status !== 200) {
      throw new Error(`Ollama API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const rawResponse = data.response || "";
    const suggestions = this.parseResponse(rawResponse);
    return {
      suggestions,
      reasoning: this.extractReasoning(rawResponse),
      rawResponse
    };
  }
  async testConnection() {
    try {
      const response = await (0, import_obsidian6.requestUrl)({
        url: `${this.endpoint}/api/tags`,
        method: "GET"
      });
      return response.status === 200;
    } catch (e) {
      return false;
    }
  }
  buildPrompt(request) {
    return `${request.systemPrompt}

---

User content to file:

${request.userContent}`;
  }
  extractReasoning(rawResponse) {
    try {
      const parsed = JSON.parse(rawResponse);
      return parsed.reasoning || parsed.explanation || "";
    } catch (e) {
      return "";
    }
  }
};

// src/providers/openrouterProvider.ts
var import_obsidian7 = require("obsidian");
var OpenRouterProvider = class extends LLMProvider {
  constructor(apiKey, model) {
    super();
    this.name = "OpenRouter";
    this.apiKey = apiKey;
    this.model = model;
  }
  async sendRequest(request) {
    var _a, _b;
    const response = await (0, import_obsidian7.requestUrl)({
      url: "https://openrouter.ai/api/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": "https://obsidian.md",
        "X-Title": "JDex AI Filer"
      },
      body: JSON.stringify({
        model: this.model,
        messages: [
          {
            role: "system",
            content: request.systemPrompt
          },
          {
            role: "user",
            content: request.userContent
          }
        ],
        max_tokens: request.maxTokens,
        temperature: request.temperature
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenRouter API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const rawResponse = ((_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "";
    const suggestions = this.parseResponse(rawResponse);
    return {
      suggestions,
      reasoning: this.extractReasoning(rawResponse),
      rawResponse
    };
  }
  async testConnection() {
    try {
      const response = await (0, import_obsidian7.requestUrl)({
        url: "https://openrouter.ai/api/v1/models",
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        }
      });
      return response.status === 200;
    } catch (e) {
      return false;
    }
  }
  extractReasoning(rawResponse) {
    try {
      const parsed = JSON.parse(rawResponse);
      return parsed.reasoning || parsed.explanation || "";
    } catch (e) {
      return "";
    }
  }
};

// src/providers/providerFactory.ts
function createProvider(settings) {
  switch (settings.provider) {
    case "openai":
      return new OpenAIProvider(
        settings.openaiApiKey,
        settings.openaiModel
      );
    case "anthropic":
      return new AnthropicProvider(
        settings.anthropicApiKey,
        settings.anthropicModel
      );
    case "ollama":
      return new OllamaProvider(
        settings.ollamaEndpoint,
        settings.ollamaModel
      );
    case "openrouter":
      return new OpenRouterProvider(
        settings.openrouterApiKey,
        settings.openrouterModel
      );
    default:
      throw new Error(`Unknown provider: ${settings.provider}`);
  }
}

// src/prompts/systemPrompt.ts
var SYSTEM_PROMPT_TEMPLATE = `You are a filing assistant for a Johnny.Decimal (JDex) personal organization system.

## Your Task
Analyze the provided content and suggest the best location(s) to file it within the user's JDex system.

## Johnny.Decimal Overview
- Areas: XX-XX (e.g., 10-19) - broad life categories
- Categories: XX (e.g., 14) - specific topics within areas
- IDs: XX.XX (e.g., 14.11) - individual items where content is stored

## Filing Guidelines
1. Match content to the most specific relevant ID
2. Consider semantic meaning, not just keywords
3. If content spans multiple topics, suggest the primary location
4. Prefer existing IDs over suggesting new ones
5. Section headers (XX.X0) are for organizing, not filing
6. Reserved IDs (XX.00-XX.09) should not be used for filing

## Available JDex Locations
{JDEX_INDEX}

## Response Format
You MUST respond with valid JSON in this exact format:
{
  "suggestions": [
    {
      "jdexId": "14.11",
      "jdexName": "My computers & servers",
      "confidence": 0.85,
      "reason": "Brief explanation why this is a good location"
    }
  ],
  "reasoning": "Overall analysis of the content and filing decision"
}

## Rules
- Provide 1-{MAX_SUGGESTIONS} suggestions, ordered by confidence (highest first)
- Confidence should be between 0 and 1
- Only suggest IDs that exist in the provided index
- Be concise in reasons (1-2 sentences)
- If no good match exists, suggest the closest category with lower confidence`;
function buildSystemPrompt(jdexIndex, maxSuggestions) {
  return SYSTEM_PROMPT_TEMPLATE.replace("{JDEX_INDEX}", jdexIndex).replace("{MAX_SUGGESTIONS}", String(maxSuggestions));
}
function buildUserPrompt(content) {
  return `Please analyze the following content and suggest where to file it:

---
${content}
---

Respond with JSON only.`;
}

// src/modals/suggestionModal.ts
var import_obsidian8 = require("obsidian");
var SuggestionModal = class extends import_obsidian8.Modal {
  constructor(app, content, suggestions, defaultOptions, onConfirm) {
    super(app);
    this.selectedSuggestion = null;
    this.content = content;
    this.suggestions = suggestions;
    this.fileOptions = { ...defaultOptions };
    this.onConfirm = onConfirm;
    if (suggestions.length > 0) {
      this.selectedSuggestion = suggestions[0];
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("jdex-ai-filer-modal");
    contentEl.createEl("h2", { text: "File Content" });
    const previewContainer = contentEl.createDiv("jdex-content-preview");
    previewContainer.createEl("h4", { text: "Content to file:" });
    const preview = previewContainer.createEl("div", { cls: "jdex-preview-text" });
    preview.setText(this.truncateContent(this.content, 200));
    contentEl.createEl("h3", { text: "Suggested Locations" });
    if (this.suggestions.length === 0) {
      contentEl.createEl("p", {
        text: "No suitable locations found. Try adjusting your JDex structure.",
        cls: "jdex-no-suggestions"
      });
    } else {
      const suggestionsContainer = contentEl.createDiv("jdex-suggestions");
      this.suggestions.forEach((suggestion, index) => {
        const suggestionEl = suggestionsContainer.createDiv("jdex-suggestion");
        if (index === 0) {
          suggestionEl.addClass("jdex-suggestion-selected");
        }
        const radioId = `suggestion-${index}`;
        const radio = suggestionEl.createEl("input", {
          type: "radio",
          attr: {
            id: radioId,
            name: "suggestion",
            value: index.toString()
          }
        });
        if (index === 0) {
          radio.checked = true;
        }
        radio.addEventListener("change", () => {
          this.selectedSuggestion = suggestion;
          suggestionsContainer.querySelectorAll(".jdex-suggestion").forEach((el) => {
            el.removeClass("jdex-suggestion-selected");
          });
          suggestionEl.addClass("jdex-suggestion-selected");
        });
        const label = suggestionEl.createEl("label", {
          attr: { for: radioId }
        });
        const idSpan = label.createSpan({ cls: "jdex-suggestion-id" });
        idSpan.setText(suggestion.jdexId);
        const nameSpan = label.createSpan({ cls: "jdex-suggestion-name" });
        nameSpan.setText(suggestion.jdexName);
        const confidenceSpan = label.createSpan({ cls: "jdex-suggestion-confidence" });
        confidenceSpan.setText(`${Math.round(suggestion.confidence * 100)}%`);
        const reasonEl = suggestionEl.createDiv({ cls: "jdex-suggestion-reason" });
        reasonEl.setText(suggestion.reason);
      });
    }
    contentEl.createEl("h3", { text: "Options" });
    new import_obsidian8.Setting(contentEl).setName("Add timestamp").addToggle((toggle) => toggle.setValue(this.fileOptions.addTimestamp).onChange((value) => {
      this.fileOptions.addTimestamp = value;
    }));
    new import_obsidian8.Setting(contentEl).setName("Under header").setDesc("Append under this header (leave empty for end of file)").addText((text) => text.setPlaceholder("## Notes").setValue(this.fileOptions.header || "").onChange((value) => {
      this.fileOptions.header = value;
    }));
    const buttonContainer = contentEl.createDiv("jdex-modal-buttons");
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const confirmBtn = buttonContainer.createEl("button", {
      text: "File It",
      cls: "mod-cta"
    });
    confirmBtn.addEventListener("click", () => {
      if (this.selectedSuggestion) {
        this.onConfirm(this.selectedSuggestion, this.fileOptions);
        this.close();
      } else {
        new import_obsidian8.Notice("Please select a location");
      }
    });
    if (this.suggestions.length === 0) {
      confirmBtn.disabled = true;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  truncateContent(content, maxLength) {
    if (content.length <= maxLength) return content;
    return content.substring(0, maxLength) + "...";
  }
};

// src/modals/inputModal.ts
var import_obsidian9 = require("obsidian");
var InputModal = class extends import_obsidian9.Modal {
  constructor(app, plugin) {
    super(app);
    this.content = "";
    this.destinationMode = "ai";
    this.selectedDestination = null;
    this.dropdownItems = [];
    this.dropdown = null;
    this.plugin = plugin;
    this.addTimestamp = plugin.settings.addTimestamp;
    this.header = plugin.settings.defaultHeader;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("jdex-input-modal");
    contentEl.createEl("h2", { text: "JDex AI Filer" });
    await this.loadDropdownItems();
    contentEl.createEl("h4", { text: "Content to file:" });
    const textAreaContainer = contentEl.createDiv("jdex-textarea-container");
    const textArea = textAreaContainer.createEl("textarea", {
      cls: "jdex-input-textarea",
      attr: { placeholder: "Type or paste content here..." }
    });
    textArea.addEventListener("input", () => {
      this.content = textArea.value;
    });
    contentEl.createEl("h4", { text: "Destination" });
    const aiOption = contentEl.createDiv("jdex-radio-option");
    const aiRadio = aiOption.createEl("input", {
      type: "radio",
      attr: { id: "dest-ai", name: "destination", value: "ai", checked: true }
    });
    aiOption.createEl("label", {
      text: "Let AI suggest",
      attr: { for: "dest-ai" }
    });
    const manualOption = contentEl.createDiv("jdex-radio-option");
    const manualRadio = manualOption.createEl("input", {
      type: "radio",
      attr: { id: "dest-manual", name: "destination", value: "manual" }
    });
    const manualLabel = manualOption.createEl("label", {
      text: "Pick manually: ",
      attr: { for: "dest-manual" }
    });
    const dropdownContainer = manualOption.createSpan("jdex-dropdown-container");
    new import_obsidian9.Setting(dropdownContainer).addDropdown((dropdown) => {
      this.dropdown = dropdown;
      dropdown.addOption("", "-- Select location --");
      for (const item of this.dropdownItems) {
        dropdown.addOption(item.id, item.label);
      }
      dropdown.onChange((value) => {
        this.selectedDestination = this.dropdownItems.find((i) => i.id === value) || null;
      });
      dropdown.selectEl.disabled = true;
    });
    aiRadio.addEventListener("change", () => {
      this.destinationMode = "ai";
      if (this.dropdown) this.dropdown.selectEl.disabled = true;
    });
    manualRadio.addEventListener("change", () => {
      this.destinationMode = "manual";
      if (this.dropdown) this.dropdown.selectEl.disabled = false;
    });
    contentEl.createEl("h4", { text: "Options" });
    new import_obsidian9.Setting(contentEl).setName("Add timestamp").addToggle((toggle) => toggle.setValue(this.addTimestamp).onChange((value) => {
      this.addTimestamp = value;
    }));
    new import_obsidian9.Setting(contentEl).setName("Under header").setDesc("Append under this header (leave empty for end of file)").addText((text) => text.setPlaceholder("## Notes").setValue(this.header).onChange((value) => {
      this.header = value;
    }));
    const buttonContainer = contentEl.createDiv("jdex-modal-buttons");
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const fileBtn = buttonContainer.createEl("button", {
      text: "File It",
      cls: "mod-cta"
    });
    fileBtn.addEventListener("click", () => this.handleSubmit());
  }
  async loadDropdownItems() {
    try {
      this.dropdownItems = await this.plugin.jdexParser.getItemsForDropdown(
        this.plugin.settings.jdexRootFolder
      );
    } catch (error) {
      console.error("Failed to load JDex items:", error);
      this.dropdownItems = [];
    }
  }
  async handleSubmit() {
    if (!this.content.trim()) {
      new import_obsidian9.Notice("Please enter content to file");
      return;
    }
    const options = {
      addTimestamp: this.addTimestamp,
      timestampFormat: this.plugin.settings.timestampFormat,
      header: this.header
    };
    if (this.destinationMode === "manual") {
      if (!this.selectedDestination) {
        new import_obsidian9.Notice("Please select a destination");
        return;
      }
      this.close();
      await this.plugin.fileToDestination(this.content, this.selectedDestination, options);
    } else {
      this.close();
      await this.plugin.fileContent(this.content);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/services/filingService.ts
var import_obsidian10 = require("obsidian");
var fs2 = __toESM(require("fs"));
var path2 = __toESM(require("path"));
var FilingService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Append content to a JDex file (vault or external)
   */
  async fileContent(content, suggestion, options) {
    if (isAbsolutePath(suggestion.targetPath)) {
      await this.fileToExternal(content, suggestion.targetPath, options);
    } else {
      await this.fileToVault(content, suggestion.targetPath, options);
    }
  }
  /**
   * Append content to a vault file
   */
  async fileToVault(content, targetPath, options) {
    var _a;
    let file = this.app.vault.getAbstractFileByPath(targetPath);
    let existingContent = "";
    if (file instanceof import_obsidian10.TFile) {
      existingContent = await this.app.vault.read(file);
    } else {
      const fileName = ((_a = targetPath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "Notes";
      existingContent = `# ${fileName}
`;
      await this.app.vault.create(targetPath, existingContent);
      file = this.app.vault.getAbstractFileByPath(targetPath);
      if (!(file instanceof import_obsidian10.TFile)) {
        throw new Error(`Failed to create file: ${targetPath}`);
      }
    }
    const appendContent = this.formatContent(content, options);
    if (options.header) {
      existingContent = this.appendUnderHeader(
        existingContent,
        options.header,
        appendContent
      );
    } else {
      existingContent += appendContent;
    }
    await this.app.vault.modify(file, existingContent);
  }
  /**
   * Append content to an external file (outside vault)
   */
  async fileToExternal(content, targetPath, options) {
    const appendContent = this.formatContent(content, options);
    let existingContent = "";
    if (fs2.existsSync(targetPath)) {
      existingContent = fs2.readFileSync(targetPath, "utf-8");
    } else {
      const dir = path2.dirname(targetPath);
      if (!fs2.existsSync(dir)) {
        throw new Error(`Folder not found: ${dir}`);
      }
      const fileName = path2.basename(targetPath, ".md");
      existingContent = `# ${fileName}
`;
    }
    if (options.header) {
      existingContent = this.appendUnderHeader(
        existingContent,
        options.header,
        appendContent
      );
    } else {
      existingContent += appendContent;
    }
    fs2.writeFileSync(targetPath, existingContent, "utf-8");
  }
  /**
   * Format content with timestamp if requested
   */
  formatContent(content, options) {
    let appendContent = "\n\n";
    if (options.addTimestamp) {
      const timestamp = (0, import_obsidian10.moment)().format(options.timestampFormat);
      appendContent += `*Filed: ${timestamp}*

`;
    }
    appendContent += content;
    return appendContent;
  }
  /**
   * Append content under a specific header
   */
  appendUnderHeader(fileContent, header, contentToAppend) {
    const headerPattern = new RegExp(
      `^(${this.escapeRegex(header)})\\s*$`,
      "m"
    );
    const match = fileContent.match(headerPattern);
    if (!match) {
      return fileContent + "\n\n" + header + "\n" + contentToAppend;
    }
    const headerIndex = match.index;
    const afterHeader = fileContent.substring(headerIndex + match[0].length);
    const nextHeaderMatch = afterHeader.match(/\n(#{1,6}\s+)/);
    if (nextHeaderMatch) {
      const insertPosition = headerIndex + match[0].length + nextHeaderMatch.index;
      return fileContent.substring(0, insertPosition) + contentToAppend + "\n" + fileContent.substring(insertPosition);
    } else {
      return fileContent + contentToAppend;
    }
  }
  /**
   * Escape special regex characters
   */
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Get a preview of where content will be filed
   */
  async getFilePreview(targetPath) {
    let content;
    if (isAbsolutePath(targetPath)) {
      if (!fs2.existsSync(targetPath)) {
        return "File not found";
      }
      content = fs2.readFileSync(targetPath, "utf-8");
    } else {
      const file = this.app.vault.getAbstractFileByPath(targetPath);
      if (!(file instanceof import_obsidian10.TFile)) {
        return "File not found";
      }
      content = await this.app.vault.read(file);
    }
    const lines = content.split("\n");
    const previewLines = lines.slice(0, 10);
    return previewLines.join("\n") + (lines.length > 10 ? "\n..." : "");
  }
};

// src/main.ts
var JDexAIFilerPlugin = class extends import_obsidian11.Plugin {
  constructor() {
    super(...arguments);
    this.ribbonIconEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.jdexParser = new JDexParser(this.app);
    this.filingService = new FilingService(this.app);
    if (this.settings.showInRibbon) {
      this.setupRibbonIcon();
    }
    this.addCommand({
      id: "file-selected-text",
      name: "File selected text",
      editorCallback: (editor, view) => {
        const selectedText = editor.getSelection();
        if (!selectedText) {
          new import_obsidian11.Notice("No text selected");
          return;
        }
        this.fileContent(selectedText);
      }
    });
    this.addCommand({
      id: "file-current-note",
      name: "File current note content",
      editorCallback: (editor, view) => {
        const content = editor.getValue();
        if (!content) {
          new import_obsidian11.Notice("Note is empty");
          return;
        }
        this.fileContent(content);
      }
    });
    this.addCommand({
      id: "open-filer",
      name: "File selected text (quick)",
      callback: () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian11.MarkdownView);
        if (view) {
          const editor = view.editor;
          const selectedText = editor.getSelection();
          if (selectedText) {
            this.fileContent(selectedText);
          } else {
            new import_obsidian11.Notice('Select text to file or use "Open Filer Dialog"');
          }
        } else {
          new import_obsidian11.Notice("Open a note first");
        }
      }
    });
    this.addCommand({
      id: "open-filer-dialog",
      name: "Open Filer Dialog",
      callback: () => {
        new InputModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "clear-jdex-cache",
      name: "Clear JDex index cache",
      callback: () => {
        this.jdexParser.clearCache();
        new import_obsidian11.Notice("JDex index cache cleared");
      }
    });
    this.addSettingTab(new JDexAIFilerSettingTab(this.app, this));
    console.log("JDex AI Filer loaded");
  }
  onunload() {
    console.log("JDex AI Filer unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.settings.showInRibbon && !this.ribbonIconEl) {
      this.setupRibbonIcon();
    } else if (!this.settings.showInRibbon && this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
    }
  }
  setupRibbonIcon() {
    this.ribbonIconEl = this.addRibbonIcon("file-input", "JDex AI Filer", () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian11.MarkdownView);
      if (view) {
        const editor = view.editor;
        const selectedText = editor.getSelection();
        if (selectedText) {
          this.fileContent(selectedText);
        } else {
          new import_obsidian11.Notice("Select text to file");
        }
      } else {
        new import_obsidian11.Notice("Open a note first");
      }
    });
  }
  async fileContent(content) {
    const validationError = this.validateProviderConfig();
    if (validationError) {
      new import_obsidian11.Notice(validationError);
      return;
    }
    new import_obsidian11.Notice("Analyzing content...");
    try {
      const index = await this.jdexParser.getIndex(
        this.settings.jdexRootFolder,
        this.settings.cacheJdexIndex,
        this.settings.cacheTimeout
      );
      if (index.areas.length === 0) {
        const location = this.settings.jdexRootFolder || "vault root";
        new import_obsidian11.Notice(`No JDex structure found in ${location}. Create folders like "10-19 Area name"`);
        return;
      }
      const indexText = buildCompactIndex(index);
      const systemPrompt = buildSystemPrompt(indexText, this.settings.maxSuggestions);
      const userPrompt = buildUserPrompt(content);
      const provider = createProvider(this.settings);
      const response = await provider.sendRequest({
        systemPrompt,
        userContent: userPrompt,
        maxTokens: this.settings.maxTokens,
        temperature: this.settings.temperature
      });
      if (response.suggestions.length === 0) {
        new import_obsidian11.Notice("No filing suggestions found. Content may not match any JDex location.");
        return;
      }
      console.log("JDex AI Filer - AI suggestions:", response.suggestions.map((s) => s.jdexId));
      for (const suggestion of response.suggestions) {
        const item = await this.jdexParser.findById(suggestion.jdexId, this.settings.jdexRootFolder);
        console.log(`JDex AI Filer - Looking for ${suggestion.jdexId}:`, item ? "FOUND at " + item.path : "NOT FOUND");
        if (item) {
          suggestion.targetPath = item.path;
          suggestion.jdexName = item.name;
        }
      }
      const validSuggestions = response.suggestions.filter((s) => s.targetPath);
      if (validSuggestions.length === 0) {
        const suggestedIds = response.suggestions.map((s) => s.jdexId).join(", ");
        new import_obsidian11.Notice(`AI suggested: ${suggestedIds}
But these IDs were not found in your JDex folder.`, 8e3);
        console.error("JDex AI Filer - Root folder:", this.settings.jdexRootFolder);
        console.error("JDex AI Filer - Suggested IDs not found:", suggestedIds);
        return;
      }
      const defaultOptions = {
        addTimestamp: this.settings.addTimestamp,
        timestampFormat: this.settings.timestampFormat,
        header: this.settings.defaultHeader
      };
      new SuggestionModal(
        this.app,
        content,
        validSuggestions,
        defaultOptions,
        async (suggestion, options) => {
          await this.performFiling(content, suggestion, options);
        }
      ).open();
    } catch (error) {
      console.error("JDex AI Filer error:", error);
      new import_obsidian11.Notice("Error: " + error.message);
    }
  }
  async performFiling(content, suggestion, options) {
    try {
      await this.filingService.fileContent(content, suggestion, options);
      if (isAbsolutePath(suggestion.targetPath)) {
        new import_obsidian11.Notice(`\u2713 Filed to ${suggestion.jdexId} ${suggestion.jdexName}
${suggestion.targetPath}`, 5e3);
      } else {
        const file = this.app.vault.getAbstractFileByPath(suggestion.targetPath);
        if (file instanceof import_obsidian11.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
        new import_obsidian11.Notice(`\u2713 Filed to ${suggestion.jdexId} ${suggestion.jdexName}`, 5e3);
      }
    } catch (error) {
      console.error("Filing error:", error);
      new import_obsidian11.Notice("Failed to file content: " + error.message);
    }
  }
  /**
   * File content directly to a manually selected destination
   */
  async fileToDestination(content, destination, options) {
    try {
      const suggestion = {
        jdexId: destination.id,
        jdexName: destination.label.replace(`${destination.id} - `, ""),
        targetPath: destination.path
      };
      await this.filingService.fileContent(content, suggestion, options);
      if (isAbsolutePath(suggestion.targetPath)) {
        new import_obsidian11.Notice(`\u2713 Filed to ${suggestion.jdexId} ${suggestion.jdexName}
${suggestion.targetPath}`, 5e3);
      } else {
        const file = this.app.vault.getAbstractFileByPath(suggestion.targetPath);
        if (file instanceof import_obsidian11.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
        new import_obsidian11.Notice(`\u2713 Filed to ${suggestion.jdexId} ${suggestion.jdexName}`, 5e3);
      }
    } catch (error) {
      console.error("Filing error:", error);
      new import_obsidian11.Notice("Failed to file content: " + error.message);
    }
  }
  validateProviderConfig() {
    const { provider } = this.settings;
    if (provider === "openai" && !this.settings.openaiApiKey) {
      return "OpenAI API key not configured. Go to Settings > JDex AI Filer";
    }
    if (provider === "anthropic" && !this.settings.anthropicApiKey) {
      return "Anthropic API key not configured. Go to Settings > JDex AI Filer";
    }
    if (provider === "ollama" && !this.settings.ollamaEndpoint) {
      return "Ollama endpoint not configured. Go to Settings > JDex AI Filer";
    }
    if (provider === "openrouter" && !this.settings.openrouterApiKey) {
      return "OpenRouter API key not configured. Go to Settings > JDex AI Filer";
    }
    return null;
  }
};
